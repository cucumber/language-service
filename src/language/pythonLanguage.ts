import { StringOrRegExp } from '@cucumber/cucumber-expressions'

import { Language, TreeSitterSyntaxNode } from './types.js'

export const pythonLanguage: Language = {
  toParameterTypeName(node: TreeSitterSyntaxNode) {
    switch (node.type) {
      case 'string': {
        return stringLiteral(node.text)
      }
      case 'concatenated_string': {
        return concatStringLiteral(node.text)
      }
      case 'identifier': {
        return node.text
      }
      default: {
        throw new Error(`Unsupported node type ${node.type}`)
      }
    }
  },
  toParameterTypeRegExps(node: TreeSitterSyntaxNode) {
    switch (node.type) {
      case 'string': {
        return RegExp(cleanRegExp(stringLiteral(node.text)))
      }
      case 'concatenated_string': {
        return RegExp(cleanRegExp(concatStringLiteral(node.text)))
      }
      case 'identifier': {
        return RegExp(cleanRegExp(stringLiteral(node.text)))
      }
      default: {
        throw new Error(`Unsupported node type ${node.type}`)
      }
    }
  },
  toStepDefinitionExpression(node: TreeSitterSyntaxNode): StringOrRegExp {
    // This removes the head and tail apostrophes.
    // TODO: This should be temporary. Python supports
    // a wider array of regex features than javascript
    // a singular way of communicating regex consistent
    // across languages is necessary
    return toStringOrRegExp(node.text)
  },
  defineParameterTypeQueries: [
    `(call
      arguments: (argument_list
        (keyword_argument
          name: (identifier) @name-key
          value: (string) @name
          (#eq? @name-key "name")
        )?
        (keyword_argument
          name: (identifier) @regexp-key
          value: (string) @expression
          (#eq? @regexp-key "regexp")
        )?
        (keyword_argument
          name: (identifier) @regexp-key
          value: (concatenated_string) @expression
          (#eq? @regexp-key "regexp")
        )?
     ))@root`,
  ],
  defineStepDefinitionQueries: [
    `
    (decorated_definition
      (decorator
        (call
          function: (identifier) @method
          arguments: (argument_list (string) @expression)
        )
      )
      (#match? @method "(given|when|then)")
    ) @root
`,
  ],
  snippetParameters: {
    int: { type: 'int' },
    float: { type: 'float' },
    word: { type: 'str' },
    string: { type: 'str' },
    double: { type: 'double' },
    bigdecimal: { type: 'decimal' },
    byte: { type: 'byte' },
    short: { type: 'short' },
    long: { type: 'long' },
    biginteger: { type: 'int' },
    '': { type: 'Object', name: 'arg' },
  },
  defaultSnippetTemplate: `
@{{ #lowercase }}{{ keyword }}{{ /lowercase }}('{{ expression }}')
def step_{{ #lowercase }}{{ keyword }}{{ /lowercase }}(context{{ #parameters }}, {{ name }}{{ /parameters }}):
    # This was autogenerated using cucumber syntax.
    # Please convert to use regular expressions, as Behave does not currently support Cucumber Expressions.`,
}

function cleanRegExp(regExpString: string): string {
  const startsWith = regExpString[0]
  switch (startsWith) {
    case '/':
      return regExpString.slice(1, -1)
    default:
      return regExpString
  }
}
export function toStringOrRegExp(step: string): StringOrRegExp {
  // Remove explicit 'u' unicode prefix
  const isUString = step.startsWith('u')
  const stepText = isUString ? step.slice(1) : step

  const strippedStepText = stepText.slice(1, -1)
  return isRegExp(strippedStepText)
    ? RegExp(cleanRegExp(strippedStepText.split('?P').join('')))
    : strippedStepText
}
export function concatStringLiteral(text: string): string {
  const isFString = text.startsWith('f')
  const cleanWord = isFString ? text.slice(1) : text
  const postSplitCleanWord = cleanWord
    .split('\\\n')
    .map((x) => x.replace(/"/g, ''))
    .map((x) => x.trim())
    .join('')
  return postSplitCleanWord
}

export function stringLiteral(text: string): string {
  const isFString = text.startsWith('f')
  const cleanWord = isFString ? text.slice(1).slice(1, -1) : text.slice(1, -1)
  return cleanWord
}

export function isRegExp(cleanWord: string): boolean {
  const startsWithSlash = cleanWord.startsWith('/')
  const namedGroupMatch = /\?P/
  const specialCharsMatch = /\(|\)|\.|\*|\\|\|/
  const containsNamedGroups = namedGroupMatch.test(cleanWord)
  const containsSpecialChars = specialCharsMatch.test(cleanWord)
  return startsWithSlash || containsNamedGroups || containsSpecialChars
}
